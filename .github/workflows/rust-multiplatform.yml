name: Rust OmniForge Build

# 触发条件：推送至 main 分支或手动触发
on:
  push:
    branches: [ main ]
    tags: [ 'v*', '*' ]
  workflow_dispatch:

# 权限设置：允许写入内容以便上传产物
permissions:
  contents: write

# 定义构建作业
jobs:
  build-and-package:
    name: Build and Package for ${{ matrix.os }}-${{ matrix.target }}
    runs-on: ${{ matrix.os }}

    # 矩阵策略：定义操作系统和目标架构组合
    strategy:
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]
        target: [ x86_64-unknown-linux-gnu, aarch64-unknown-linux-gnu, x86_64-apple-darwin, aarch64-apple-darwin, x86_64-pc-windows-msvc ]
        exclude:
          - os: windows-latest
            target: aarch64-unknown-linux-gnu
          - os: windows-latest
            target: x86_64-unknown-linux-gnu
          - os: windows-latest
            target: aarch64-apple-darwin
          - os: windows-latest
            target: x86_64-apple-darwin
          - os: ubuntu-latest
            target: x86_64-apple-darwin
          - os: ubuntu-latest
            target: aarch64-apple-darwin
          - os: macos-latest
            target: x86_64-unknown-linux-gnu
          - os: macos-latest
            target: aarch64-unknown-linux-gnu
          - os: macos-latest
            target: x86_64-pc-windows-msvc
          - os: ubuntu-latest
            target: x86_64-pc-windows-msvc

    steps:
      # 步骤 1：检出代码
      - name: Checkout Repository
        uses: actions/checkout@v4

      # 步骤 2：安装 Rust 工具链
      - name: Install Rust Toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      # 步骤 3：缓存 Cargo 依赖
      - name: Cache Cargo Dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ matrix.os }}-${{ matrix.target }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ matrix.os }}-${{ matrix.target }}-cargo-

      # 步骤 4：在 Windows 上安装 7-Zip
      - name: Install 7-Zip (Windows)
        if: matrix.os == 'windows-latest'
        run: choco install 7zip -y
        shell: powershell

      # 步骤 5：下载压缩文件（Windows 使用 PowerShell）
      - name: Download Static Assets (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          $url = "https://dl.rustfs.com/console/console.latest.tar.gz"  # 可改为 a.tar.gz 测试
          $file = Split-Path $url -Leaf
          Invoke-WebRequest -Uri $url -OutFile $file -ErrorAction Stop
          if (!(Test-Path $file)) {
            Write-Error "Failed to download $file"
            exit 1
          }
          Get-ChildItem $file
        shell: powershell

      # 步骤 6：下载压缩文件（Linux/macOS 使用 bash）
      - name: Download Static Assets (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          url="https://dl.rustfs.com/console/console.latest.tar.gz"  # 可改为 a.zip 测试
          file=$(basename "$url")
          curl -L -o "$file" "$url"
          if [ ! -f "$file" ]; then
            echo "Error: Failed to download $file"
            exit 1
          fi
          echo "Downloaded $file successfully"
          ls -l "$file"
          ls -la
        shell: bash

      # 步骤 7：解压压缩文件（Windows 使用 PowerShell + 7-Zip）
      - name: Extract Static Assets (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          $file = Get-ChildItem *.zip,*.tar.gz -ErrorAction Stop | Select-Object -First 1
          New-Item -ItemType Directory -Path static -Force | Out-Null
          if ($file.Extension -eq ".zip") {
            7z x $file -o"static" -y
          } elseif ($file.Extension -eq ".gz") {
            7z x $file -o"static" -y  # 解压 tar.gz
          }
          Remove-Item $file
          Get-ChildItem static
        shell: powershell

      # 步骤 8：解压压缩文件（Linux/macOS 使用 bash）
      - name: Extract Static Assets (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          ls -la
          # file=$(ls *.zip *.tar.gz 2>/dev/null | head -n 1)
          # 查找第一个 .zip 或 .tar.gz 文件
          file=""
          for f in *.zip *.tar.gz; do
            if [ -f "$f" ]; then
              file="$f"
              break
            fi
          done
          if [ -z "$file" ]; then
            echo "Error: No .zip or .tar.gz file found in the current directory"
            ls -la  # 显示当前目录内容以便调试
            exit 1
          fi
          # 输出找到的文件名
          echo "Found file: $file"
          mkdir -p static
          if [[ "$file" == *.zip ]]; then
            echo "Unzipping $file to static/"
            unzip "$file" -d static || { echo "Error: Failed to unzip $file"; exit 1; }
          elif [[ "$file" == *.tar.gz ]]; then
            echo "Extracting $file to static/"
            tar -xzf "$file" -C static || { echo "Error: Failed to extract $file"; exit 1; }
          else
            echo "Error: Unsupported file format: $file"
            exit 1
          fi
          # 检查解压是否成功
          if [ $? -ne 0 ]; then
            echo "Error: Failed to extract $file"
            exit 2
          fi
          rm "$file"
          ls -la static
        shell: bash

      # 步骤 9：安装交叉编译工具链（Linux）
      - name: Install Cross-Compilation Tools (Linux)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
          aarch64-linux-gnu-gcc --version  # 验证安装
        shell: bash
      
      # 步骤 9：编译 Rust 项目（Windows 使用 PowerShell）
      - name: Build Rust Binary (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          cargo build --release --target ${{ matrix.target }} --verbose
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Rust build failed"
            exit 1
          }
        shell: powershell

      # 步骤 10：编译 Rust 项目（Linux/macOS 使用 bash）
      - name: Build Rust Binary (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          # 根据目标配置链接器
               case "${{ matrix.target }}" in
               "x86_64-unknown-linux-gnu")
          # 默认 gcc
               export CC_x86_64_unknown_linux_gnu=gcc
               export CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_LINKER=gcc
               ;;
               "aarch64-unknown-linux-gnu")
          # AArch64 交叉编译器
               export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
               export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
               ;;
               "x86_64-apple-darwin")
          # macOS 默认 clang
               export CC_x86_64_apple_darwin=clang
               export CARGO_TARGET_X86_64_APPLE_DARWIN_LINKER=clang
               ;;
               "aarch64-apple-darwin")
          # macOS ARM64 使用 clang
               export CC_aarch64_apple_darwin=clang
               export CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER=clang
               ;;
          esac
          # 验证环境变量（调试用）
               echo "CC for ${{ matrix.target }}: $CC_${{ matrix.target }}"
               echo "Linker for ${{ matrix.target }}: $CARGO_TARGET_${{ matrix.target }}_LINKER"
          # 执行编译
               cargo build --release --target ${{ matrix.target }} --verbose
               if [ $? -ne 0 ]; then
               echo "Rust build failed"
               exit 1
               fi
        shell: bash

      # 设置 TAG 值
      - name: Set Tag Variable
        run: |
          # 初始化 TAG
          TAG="notag"
          # 如果是 pull_request，使用 "main"
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            TAG="main"
          # 如果是 tag 推送，使用 tag 值
          elif [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" =~ ^refs/tags/ ]]; then
            TAG="${{ github.ref_name }}"
          fi
          echo "TAG=$TAG" >> $GITHUB_ENV
          echo "Set TAG to: $TAG"
        shell: bash

      # 步骤 11：打包二进制文件和 static 目录（Windows 使用 PowerShell）
      - name: Package Binary and Static Assets (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          New-Item -ItemType Directory -Path release-package -Force | Out-Null
          Copy-Item "target/${{ matrix.target }}/release/rst-action.exe" -Destination release-package/
          Copy-Item -Recurse static release-package/
          7z a "release-package-${{ matrix.target }}-${{ matrix.os }}-${{ env.TAG }}.zip" "release-package/*" -r
          Get-ChildItem .
        shell: powershell

      # 步骤 12：打包二进制文件和 static 目录（Linux/macOS 使用 bash）
      - name: Package Binary and Static Assets (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          mkdir -p release-package
          cp target/${{ matrix.target }}/release/rst-action release-package/
          cp -r static release-package/
          zip -r release-package-${{ matrix.target }}-${{ matrix.os }}-${{ env.TAG }}.zip release-package/*
          ls -la
        shell: bash

      # 步骤 13：上传压缩文件作为构建产物（使用 v4）
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-package-${{ matrix.target }}-${{ matrix.os }}-${{ env.TAG }}
          path: release-package-${{ matrix.target }}-${{ matrix.os }}-${{ env.TAG }}.zip

      - name: Debug GitHub Context
        run: echo "github.ref = ${{ github.ref }}"

      - name: Check Artifact Before Release
        run: |
          if [ ! -f "release-package-${{ matrix.target }}-${{ matrix.os }}-${{ env.TAG }}.zip" ]; then
            echo "Error: File release-package-${{ matrix.target }}-${{ matrix.os }}-${{ env.TAG }}.zip not found"
            ls -la || dir
            exit 1
          fi
        shell: bash

release:
  needs: build-and-package
  runs-on: ubuntu-latest
  if: startsWith(github.ref, 'refs/tags/')
  steps:
    - name: Download All Artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
    # 步骤 14：发布到 GitHub Releases（使用 v2）
    - name: Release Package
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ github.ref_name }}
        name: RST Action Release ${{ github.ref_name }}
        draft: false
        prerelease: false
        files: artifacts/**/*.zip
        token: ${{ secrets.GITHUB_TOKEN }}  # 显式使用 GITHUB_TOKEN
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # 确保环境变量可用